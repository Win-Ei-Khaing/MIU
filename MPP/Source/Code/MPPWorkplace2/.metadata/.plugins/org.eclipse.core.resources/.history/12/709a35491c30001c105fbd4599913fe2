package lambdalib;

import java.util.Comparator;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collectors;

import quizclasses.Employee;
import quizclasses.Pair;
import quizclasses.TraderPair;
import quizclasses.Transaction;
import quizclasses.Util;


public class LambdaLibrary {
	public final static String IMPLEMENT = "implement!";
	
	//sample query
	public final static TriFunction<List<Employee>, Integer, Integer, List<Employee>> SAMPLE
	   = (list, namelength, year) -> list.stream()
	                                     .filter(e -> e.getName().length() > namelength)
	                                     .filter(e -> e.getYearOfBirth() > year)
	                                     .collect(Collectors.toList());
	   
	  public final static TriFunction<List<Employee>, Integer, Integer, List<Pair>> PROB1
	  =(list, minSalary, maxSalary) -> list.stream()
		.filter(e->(e.getSalary()>minSalary && e.getSalary()<maxSalary))
		.sorted(Comparator.comparing(Employee::getName).thenComparing(Employee::getSalary))
		.map((Employee e)->new Pair(e.getName(), e.getSalary()))
		.collect(Collectors.toList());
	  
	  public final static BiFunction<List<Transaction>, Integer, List<Transaction>> PROB2
	  =(list, filterYear)->list.stream()
		.filter(t->(t.getYear()==filterYear))
		.sorted(Comparator.comparing(Transaction::getValue))
		.collect(Collectors.toList());
	  
	  public final static Function<List<Transaction>, List<TraderPair>> PROB3
			  =list->Util.allTraderPairs(list.stream().map(t->t.getTrader()))
				.filter(tp->tp.getTrader1().isAssociate(tp.getTrader2()))
				.filter(tp->tp.getTrader1().getCity().equals(tp.getTrader2().getCity()))
				//.collect(Collectors.toList())
				.distinct();
}
